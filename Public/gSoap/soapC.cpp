/* soapC.cpp
   Generated by gSOAP 2.8.32 for add.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.32 2016-07-07 06:17:58 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns__syndwsaTicketInfo:
		return soap_in_ns__syndwsaTicketInfo(soap, NULL, NULL, "ns:syndwsaTicketInfo");
	case SOAP_TYPE_ns__syndwsaTicketInfoResponse:
		return soap_in_ns__syndwsaTicketInfoResponse(soap, NULL, NULL, "ns:syndwsaTicketInfoResponse");
	case SOAP_TYPE_SyndwsaTicketInfoResponse:
		return soap_in_SyndwsaTicketInfoResponse(soap, NULL, NULL, "SyndwsaTicketInfoResponse");
	case SOAP_TYPE_SyndwsaTicketInfoRequest:
		return soap_in_SyndwsaTicketInfoRequest(soap, NULL, NULL, "SyndwsaTicketInfoRequest");
	case SOAP_TYPE_ns__Syndwsadata:
		return soap_in_ns__Syndwsadata(soap, NULL, NULL, "ns:Syndwsadata");
	case SOAP_TYPE_ns__SyndwsadataResponse:
		return soap_in_ns__SyndwsadataResponse(soap, NULL, NULL, "ns:SyndwsadataResponse");
	case SOAP_TYPE_SyndwsadataRequest:
		return soap_in_SyndwsadataRequest(soap, NULL, NULL, "SyndwsadataRequest");
	case SOAP_TYPE_SyndwsadataResponse:
		return soap_in_SyndwsadataResponse(soap, NULL, NULL, "SyndwsadataResponse");
	case SOAP_TYPE_TermInfoPojo:
		return soap_in_TermInfoPojo(soap, NULL, NULL, "TermInfoPojo");
	case SOAP_TYPE_PropInfoPojo:
		return soap_in_PropInfoPojo(soap, NULL, NULL, "PropInfoPojo");
	case SOAP_TYPE_PointerToSyndwsaTicketInfoResponse:
		return soap_in_PointerToSyndwsaTicketInfoResponse(soap, NULL, NULL, "SyndwsaTicketInfoResponse");
	case SOAP_TYPE_PointerToSyndwsadataResponse:
		return soap_in_PointerToSyndwsadataResponse(soap, NULL, NULL, "SyndwsadataResponse");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:syndwsaTicketInfo"))
		{	*type = SOAP_TYPE_ns__syndwsaTicketInfo;
			return soap_in_ns__syndwsaTicketInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:syndwsaTicketInfoResponse"))
		{	*type = SOAP_TYPE_ns__syndwsaTicketInfoResponse;
			return soap_in_ns__syndwsaTicketInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SyndwsaTicketInfoResponse"))
		{	*type = SOAP_TYPE_SyndwsaTicketInfoResponse;
			return soap_in_SyndwsaTicketInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SyndwsaTicketInfoRequest"))
		{	*type = SOAP_TYPE_SyndwsaTicketInfoRequest;
			return soap_in_SyndwsaTicketInfoRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:Syndwsadata"))
		{	*type = SOAP_TYPE_ns__Syndwsadata;
			return soap_in_ns__Syndwsadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:SyndwsadataResponse"))
		{	*type = SOAP_TYPE_ns__SyndwsadataResponse;
			return soap_in_ns__SyndwsadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SyndwsadataRequest"))
		{	*type = SOAP_TYPE_SyndwsadataRequest;
			return soap_in_SyndwsadataRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SyndwsadataResponse"))
		{	*type = SOAP_TYPE_SyndwsadataResponse;
			return soap_in_SyndwsadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "TermInfoPojo"))
		{	*type = SOAP_TYPE_TermInfoPojo;
			return soap_in_TermInfoPojo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "PropInfoPojo"))
		{	*type = SOAP_TYPE_PropInfoPojo;
			return soap_in_PropInfoPojo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns__syndwsaTicketInfo:
		return soap_out_ns__syndwsaTicketInfo(soap, tag, id, (const struct ns__syndwsaTicketInfo *)ptr, "ns:syndwsaTicketInfo");
	case SOAP_TYPE_ns__syndwsaTicketInfoResponse:
		return soap_out_ns__syndwsaTicketInfoResponse(soap, tag, id, (const struct ns__syndwsaTicketInfoResponse *)ptr, "ns:syndwsaTicketInfoResponse");
	case SOAP_TYPE_SyndwsaTicketInfoResponse:
		return soap_out_SyndwsaTicketInfoResponse(soap, tag, id, (const struct SyndwsaTicketInfoResponse *)ptr, "SyndwsaTicketInfoResponse");
	case SOAP_TYPE_SyndwsaTicketInfoRequest:
		return soap_out_SyndwsaTicketInfoRequest(soap, tag, id, (const struct SyndwsaTicketInfoRequest *)ptr, "SyndwsaTicketInfoRequest");
	case SOAP_TYPE_ns__Syndwsadata:
		return soap_out_ns__Syndwsadata(soap, tag, id, (const struct ns__Syndwsadata *)ptr, "ns:Syndwsadata");
	case SOAP_TYPE_ns__SyndwsadataResponse:
		return soap_out_ns__SyndwsadataResponse(soap, tag, id, (const struct ns__SyndwsadataResponse *)ptr, "ns:SyndwsadataResponse");
	case SOAP_TYPE_SyndwsadataRequest:
		return soap_out_SyndwsadataRequest(soap, tag, id, (const struct SyndwsadataRequest *)ptr, "SyndwsadataRequest");
	case SOAP_TYPE_SyndwsadataResponse:
		return soap_out_SyndwsadataResponse(soap, tag, id, (const struct SyndwsadataResponse *)ptr, "SyndwsadataResponse");
	case SOAP_TYPE_TermInfoPojo:
		return soap_out_TermInfoPojo(soap, tag, id, (const struct TermInfoPojo *)ptr, "TermInfoPojo");
	case SOAP_TYPE_PropInfoPojo:
		return soap_out_PropInfoPojo(soap, tag, id, (const struct PropInfoPojo *)ptr, "PropInfoPojo");
	case SOAP_TYPE_PointerToSyndwsaTicketInfoResponse:
		return soap_out_PointerToSyndwsaTicketInfoResponse(soap, tag, id, (struct SyndwsaTicketInfoResponse *const*)ptr, "SyndwsaTicketInfoResponse");
	case SOAP_TYPE_PointerToSyndwsadataResponse:
		return soap_out_PointerToSyndwsadataResponse(soap, tag, id, (struct SyndwsadataResponse *const*)ptr, "SyndwsadataResponse");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns__syndwsaTicketInfo:
		soap_serialize_ns__syndwsaTicketInfo(soap, (const struct ns__syndwsaTicketInfo *)ptr);
		break;
	case SOAP_TYPE_ns__syndwsaTicketInfoResponse:
		soap_serialize_ns__syndwsaTicketInfoResponse(soap, (const struct ns__syndwsaTicketInfoResponse *)ptr);
		break;
	case SOAP_TYPE_SyndwsaTicketInfoResponse:
		soap_serialize_SyndwsaTicketInfoResponse(soap, (const struct SyndwsaTicketInfoResponse *)ptr);
		break;
	case SOAP_TYPE_SyndwsaTicketInfoRequest:
		soap_serialize_SyndwsaTicketInfoRequest(soap, (const struct SyndwsaTicketInfoRequest *)ptr);
		break;
	case SOAP_TYPE_ns__Syndwsadata:
		soap_serialize_ns__Syndwsadata(soap, (const struct ns__Syndwsadata *)ptr);
		break;
	case SOAP_TYPE_ns__SyndwsadataResponse:
		soap_serialize_ns__SyndwsadataResponse(soap, (const struct ns__SyndwsadataResponse *)ptr);
		break;
	case SOAP_TYPE_SyndwsadataRequest:
		soap_serialize_SyndwsadataRequest(soap, (const struct SyndwsadataRequest *)ptr);
		break;
	case SOAP_TYPE_SyndwsadataResponse:
		soap_serialize_SyndwsadataResponse(soap, (const struct SyndwsadataResponse *)ptr);
		break;
	case SOAP_TYPE_TermInfoPojo:
		soap_serialize_TermInfoPojo(soap, (const struct TermInfoPojo *)ptr);
		break;
	case SOAP_TYPE_PropInfoPojo:
		soap_serialize_PropInfoPojo(soap, (const struct PropInfoPojo *)ptr);
		break;
	case SOAP_TYPE_PointerToSyndwsaTicketInfoResponse:
		soap_serialize_PointerToSyndwsaTicketInfoResponse(soap, (struct SyndwsaTicketInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToSyndwsadataResponse:
		soap_serialize_PointerToSyndwsadataResponse(soap, (struct SyndwsadataResponse *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_PropInfoPojo:
		return (void*)soap_instantiate_PropInfoPojo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TermInfoPojo:
		return (void*)soap_instantiate_TermInfoPojo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SyndwsadataResponse:
		return (void*)soap_instantiate_SyndwsadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SyndwsadataRequest:
		return (void*)soap_instantiate_SyndwsadataRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__SyndwsadataResponse:
		return (void*)soap_instantiate_ns__SyndwsadataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__Syndwsadata:
		return (void*)soap_instantiate_ns__Syndwsadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SyndwsaTicketInfoRequest:
		return (void*)soap_instantiate_SyndwsaTicketInfoRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SyndwsaTicketInfoResponse:
		return (void*)soap_instantiate_SyndwsaTicketInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__syndwsaTicketInfoResponse:
		return (void*)soap_instantiate_ns__syndwsaTicketInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns__syndwsaTicketInfo:
		return (void*)soap_instantiate_ns__syndwsaTicketInfo(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfTermInfoPojo:
		return (void*)soap_instantiate_std__vectorTemplateOfTermInfoPojo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPropInfoPojo:
		return (void*)soap_instantiate_std__vectorTemplateOfPropInfoPojo(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_PropInfoPojo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct PropInfoPojo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct PropInfoPojo*>(p->ptr));
		break;
	case SOAP_TYPE_TermInfoPojo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct TermInfoPojo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct TermInfoPojo*>(p->ptr));
		break;
	case SOAP_TYPE_SyndwsadataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SyndwsadataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SyndwsadataResponse*>(p->ptr));
		break;
	case SOAP_TYPE_SyndwsadataRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SyndwsadataRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SyndwsadataRequest*>(p->ptr));
		break;
	case SOAP_TYPE_ns__SyndwsadataResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__SyndwsadataResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__SyndwsadataResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__Syndwsadata:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__Syndwsadata*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__Syndwsadata*>(p->ptr));
		break;
	case SOAP_TYPE_SyndwsaTicketInfoRequest:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SyndwsaTicketInfoRequest*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SyndwsaTicketInfoRequest*>(p->ptr));
		break;
	case SOAP_TYPE_SyndwsaTicketInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SyndwsaTicketInfoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SyndwsaTicketInfoResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__syndwsaTicketInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__syndwsaTicketInfoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__syndwsaTicketInfoResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns__syndwsaTicketInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns__syndwsaTicketInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns__syndwsaTicketInfo*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfTermInfoPojo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<struct TermInfoPojo> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<struct TermInfoPojo> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPropInfoPojo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<struct PropInfoPojo> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<struct PropInfoPojo> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfTermInfoPojo:
		if (t == SOAP_TYPE_TermInfoPojo)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<struct TermInfoPojo>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<struct TermInfoPojo> *)p)[index] = *(struct TermInfoPojo *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPropInfoPojo:
		if (t == SOAP_TYPE_PropInfoPojo)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<struct PropInfoPojo>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<struct PropInfoPojo> *)p)[index] = *(struct PropInfoPojo *)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_PropInfoPojo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct PropInfoPojo type=%d location=%p object=%p\n", t, p, q));
		*(struct PropInfoPojo*)p = *(struct PropInfoPojo*)q;
		break;
	case SOAP_TYPE_TermInfoPojo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct TermInfoPojo type=%d location=%p object=%p\n", t, p, q));
		*(struct TermInfoPojo*)p = *(struct TermInfoPojo*)q;
		break;
	case SOAP_TYPE_SyndwsadataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SyndwsadataResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct SyndwsadataResponse*)p = *(struct SyndwsadataResponse*)q;
		break;
	case SOAP_TYPE_SyndwsadataRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SyndwsadataRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct SyndwsadataRequest*)p = *(struct SyndwsadataRequest*)q;
		break;
	case SOAP_TYPE_ns__SyndwsadataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__SyndwsadataResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__SyndwsadataResponse*)p = *(struct ns__SyndwsadataResponse*)q;
		break;
	case SOAP_TYPE_ns__Syndwsadata:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__Syndwsadata type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__Syndwsadata*)p = *(struct ns__Syndwsadata*)q;
		break;
	case SOAP_TYPE_SyndwsaTicketInfoRequest:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SyndwsaTicketInfoRequest type=%d location=%p object=%p\n", t, p, q));
		*(struct SyndwsaTicketInfoRequest*)p = *(struct SyndwsaTicketInfoRequest*)q;
		break;
	case SOAP_TYPE_SyndwsaTicketInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SyndwsaTicketInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct SyndwsaTicketInfoResponse*)p = *(struct SyndwsaTicketInfoResponse*)q;
		break;
	case SOAP_TYPE_ns__syndwsaTicketInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__syndwsaTicketInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__syndwsaTicketInfoResponse*)p = *(struct ns__syndwsaTicketInfoResponse*)q;
		break;
	case SOAP_TYPE_ns__syndwsaTicketInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns__syndwsaTicketInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct ns__syndwsaTicketInfo*)p = *(struct ns__syndwsaTicketInfo*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag?tag:"byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag?tag:"int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__syndwsaTicketInfo(struct soap *soap, struct ns__syndwsaTicketInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SyndwsaTicketInfoRequest(soap, &a->request);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__syndwsaTicketInfo(struct soap *soap, const struct ns__syndwsaTicketInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_SyndwsaTicketInfoRequest(soap, &a->request);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__syndwsaTicketInfo(struct soap *soap, const char *tag, int id, const struct ns__syndwsaTicketInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__syndwsaTicketInfo), type))
		return soap->error;
	if (soap_out_SyndwsaTicketInfoRequest(soap, "request", -1, &a->request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__syndwsaTicketInfo * SOAP_FMAC4 soap_in_ns__syndwsaTicketInfo(struct soap *soap, const char *tag, struct ns__syndwsaTicketInfo *a, const char *type)
{
	size_t soap_flag_request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__syndwsaTicketInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__syndwsaTicketInfo, sizeof(struct ns__syndwsaTicketInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__syndwsaTicketInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_SyndwsaTicketInfoRequest(soap, "request", &a->request, "SyndwsaTicketInfoRequest"))
				{	soap_flag_request--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_request > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__syndwsaTicketInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__syndwsaTicketInfo, SOAP_TYPE_ns__syndwsaTicketInfo, sizeof(struct ns__syndwsaTicketInfo), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__syndwsaTicketInfo * SOAP_FMAC2 soap_instantiate_ns__syndwsaTicketInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__syndwsaTicketInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__syndwsaTicketInfo *p;
	size_t k = sizeof(struct ns__syndwsaTicketInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__syndwsaTicketInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__syndwsaTicketInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__syndwsaTicketInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__syndwsaTicketInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__syndwsaTicketInfo(struct soap *soap, const struct ns__syndwsaTicketInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns__syndwsaTicketInfo(soap, tag?tag:"ns:syndwsaTicketInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__syndwsaTicketInfo * SOAP_FMAC4 soap_get_ns__syndwsaTicketInfo(struct soap *soap, struct ns__syndwsaTicketInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__syndwsaTicketInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__syndwsaTicketInfoResponse(struct soap *soap, struct ns__syndwsaTicketInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->serviceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__syndwsaTicketInfoResponse(struct soap *soap, const struct ns__syndwsaTicketInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSyndwsaTicketInfoResponse(soap, &a->serviceResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__syndwsaTicketInfoResponse(struct soap *soap, const char *tag, int id, const struct ns__syndwsaTicketInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__syndwsaTicketInfoResponse), type))
		return soap->error;
	if (soap_out_PointerToSyndwsaTicketInfoResponse(soap, "serviceResponse", -1, &a->serviceResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__syndwsaTicketInfoResponse * SOAP_FMAC4 soap_in_ns__syndwsaTicketInfoResponse(struct soap *soap, const char *tag, struct ns__syndwsaTicketInfoResponse *a, const char *type)
{
	size_t soap_flag_serviceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__syndwsaTicketInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__syndwsaTicketInfoResponse, sizeof(struct ns__syndwsaTicketInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__syndwsaTicketInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSyndwsaTicketInfoResponse(soap, "serviceResponse", &a->serviceResponse, "SyndwsaTicketInfoResponse"))
				{	soap_flag_serviceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__syndwsaTicketInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__syndwsaTicketInfoResponse, SOAP_TYPE_ns__syndwsaTicketInfoResponse, sizeof(struct ns__syndwsaTicketInfoResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__syndwsaTicketInfoResponse * SOAP_FMAC2 soap_instantiate_ns__syndwsaTicketInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__syndwsaTicketInfoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__syndwsaTicketInfoResponse *p;
	size_t k = sizeof(struct ns__syndwsaTicketInfoResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__syndwsaTicketInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__syndwsaTicketInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__syndwsaTicketInfoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__syndwsaTicketInfoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__syndwsaTicketInfoResponse(struct soap *soap, const struct ns__syndwsaTicketInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__syndwsaTicketInfoResponse(soap, tag?tag:"ns:syndwsaTicketInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__syndwsaTicketInfoResponse * SOAP_FMAC4 soap_get_ns__syndwsaTicketInfoResponse(struct soap *soap, struct ns__syndwsaTicketInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__syndwsaTicketInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SyndwsaTicketInfoResponse(struct soap *soap, struct SyndwsaTicketInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->responseVersion);
	soap_default_std__string(soap, &a->requestCtxUUID);
	soap_default_std__string(soap, &a->responseCode);
	soap_default_std__string(soap, &a->responseExtCode);
	soap_default_std__string(soap, &a->responseMessage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SyndwsaTicketInfoResponse(struct soap *soap, const struct SyndwsaTicketInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->responseVersion);
	soap_serialize_std__string(soap, &a->requestCtxUUID);
	soap_serialize_std__string(soap, &a->responseCode);
	soap_serialize_std__string(soap, &a->responseExtCode);
	soap_serialize_std__string(soap, &a->responseMessage);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SyndwsaTicketInfoResponse(struct soap *soap, const char *tag, int id, const struct SyndwsaTicketInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SyndwsaTicketInfoResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "responseVersion", -1, &a->responseVersion, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requestCtxUUID", -1, &a->requestCtxUUID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "responseCode", -1, &a->responseCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "responseExtCode", -1, &a->responseExtCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "responseMessage", -1, &a->responseMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SyndwsaTicketInfoResponse * SOAP_FMAC4 soap_in_SyndwsaTicketInfoResponse(struct soap *soap, const char *tag, struct SyndwsaTicketInfoResponse *a, const char *type)
{
	size_t soap_flag_responseVersion = 1;
	size_t soap_flag_requestCtxUUID = 1;
	size_t soap_flag_responseCode = 1;
	size_t soap_flag_responseExtCode = 1;
	size_t soap_flag_responseMessage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SyndwsaTicketInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SyndwsaTicketInfoResponse, sizeof(struct SyndwsaTicketInfoResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_SyndwsaTicketInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "responseVersion", &a->responseVersion, "xsd:string"))
				{	soap_flag_responseVersion--;
					continue;
				}
			if (soap_flag_requestCtxUUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestCtxUUID", &a->requestCtxUUID, "xsd:string"))
				{	soap_flag_requestCtxUUID--;
					continue;
				}
			if (soap_flag_responseCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "responseCode", &a->responseCode, "xsd:string"))
				{	soap_flag_responseCode--;
					continue;
				}
			if (soap_flag_responseExtCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "responseExtCode", &a->responseExtCode, "xsd:string"))
				{	soap_flag_responseExtCode--;
					continue;
				}
			if (soap_flag_responseMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "responseMessage", &a->responseMessage, "xsd:string"))
				{	soap_flag_responseMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseVersion > 0 || soap_flag_requestCtxUUID > 0 || soap_flag_responseCode > 0 || soap_flag_responseExtCode > 0 || soap_flag_responseMessage > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct SyndwsaTicketInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SyndwsaTicketInfoResponse, SOAP_TYPE_SyndwsaTicketInfoResponse, sizeof(struct SyndwsaTicketInfoResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SyndwsaTicketInfoResponse * SOAP_FMAC2 soap_instantiate_SyndwsaTicketInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SyndwsaTicketInfoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SyndwsaTicketInfoResponse *p;
	size_t k = sizeof(struct SyndwsaTicketInfoResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct SyndwsaTicketInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SyndwsaTicketInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SyndwsaTicketInfoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SyndwsaTicketInfoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SyndwsaTicketInfoResponse(struct soap *soap, const struct SyndwsaTicketInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_SyndwsaTicketInfoResponse(soap, tag?tag:"SyndwsaTicketInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SyndwsaTicketInfoResponse * SOAP_FMAC4 soap_get_SyndwsaTicketInfoResponse(struct soap *soap, struct SyndwsaTicketInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_SyndwsaTicketInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SyndwsaTicketInfoRequest(struct soap *soap, struct SyndwsaTicketInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->wtCode);
	soap_default_std__string(soap, &a->wtPlanStartTime);
	soap_default_std__string(soap, &a->wtPlanEndTime);
	soap_default_std__vectorTemplateOfPropInfoPojo(soap, &a->lstPropInfo);
	soap_default_std__vectorTemplateOfTermInfoPojo(soap, &a->lstTermInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SyndwsaTicketInfoRequest(struct soap *soap, const struct SyndwsaTicketInfoRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->wtCode);
	soap_serialize_std__string(soap, &a->wtPlanStartTime);
	soap_serialize_std__string(soap, &a->wtPlanEndTime);
	soap_serialize_std__vectorTemplateOfPropInfoPojo(soap, &a->lstPropInfo);
	soap_serialize_std__vectorTemplateOfTermInfoPojo(soap, &a->lstTermInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SyndwsaTicketInfoRequest(struct soap *soap, const char *tag, int id, const struct SyndwsaTicketInfoRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SyndwsaTicketInfoRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "wtCode", -1, &a->wtCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "wtPlanStartTime", -1, &a->wtPlanStartTime, ""))
		return soap->error;
	if (soap_out_std__string(soap, "wtPlanEndTime", -1, &a->wtPlanEndTime, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPropInfoPojo(soap, "lstPropInfo", -1, &a->lstPropInfo, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfTermInfoPojo(soap, "lstTermInfo", -1, &a->lstTermInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SyndwsaTicketInfoRequest * SOAP_FMAC4 soap_in_SyndwsaTicketInfoRequest(struct soap *soap, const char *tag, struct SyndwsaTicketInfoRequest *a, const char *type)
{
	size_t soap_flag_wtCode = 1;
	size_t soap_flag_wtPlanStartTime = 1;
	size_t soap_flag_wtPlanEndTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SyndwsaTicketInfoRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SyndwsaTicketInfoRequest, sizeof(struct SyndwsaTicketInfoRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_SyndwsaTicketInfoRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wtCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "wtCode", &a->wtCode, "xsd:string"))
				{	soap_flag_wtCode--;
					continue;
				}
			if (soap_flag_wtPlanStartTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "wtPlanStartTime", &a->wtPlanStartTime, "xsd:string"))
				{	soap_flag_wtPlanStartTime--;
					continue;
				}
			if (soap_flag_wtPlanEndTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "wtPlanEndTime", &a->wtPlanEndTime, "xsd:string"))
				{	soap_flag_wtPlanEndTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPropInfoPojo(soap, "lstPropInfo", &a->lstPropInfo, "PropInfoPojo"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfTermInfoPojo(soap, "lstTermInfo", &a->lstTermInfo, "TermInfoPojo"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wtCode > 0 || soap_flag_wtPlanStartTime > 0 || soap_flag_wtPlanEndTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct SyndwsaTicketInfoRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SyndwsaTicketInfoRequest, SOAP_TYPE_SyndwsaTicketInfoRequest, sizeof(struct SyndwsaTicketInfoRequest), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SyndwsaTicketInfoRequest * SOAP_FMAC2 soap_instantiate_SyndwsaTicketInfoRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SyndwsaTicketInfoRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SyndwsaTicketInfoRequest *p;
	size_t k = sizeof(struct SyndwsaTicketInfoRequest);
	if (n < 0)
	{	p = SOAP_NEW(struct SyndwsaTicketInfoRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SyndwsaTicketInfoRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SyndwsaTicketInfoRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SyndwsaTicketInfoRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SyndwsaTicketInfoRequest(struct soap *soap, const struct SyndwsaTicketInfoRequest *a, const char *tag, const char *type)
{
	if (soap_out_SyndwsaTicketInfoRequest(soap, tag?tag:"SyndwsaTicketInfoRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SyndwsaTicketInfoRequest * SOAP_FMAC4 soap_get_SyndwsaTicketInfoRequest(struct soap *soap, struct SyndwsaTicketInfoRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_SyndwsaTicketInfoRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__Syndwsadata(struct soap *soap, struct ns__Syndwsadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_SyndwsadataRequest(soap, &a->request);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__Syndwsadata(struct soap *soap, const struct ns__Syndwsadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_SyndwsadataRequest(soap, &a->request);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__Syndwsadata(struct soap *soap, const char *tag, int id, const struct ns__Syndwsadata *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__Syndwsadata), type))
		return soap->error;
	if (soap_out_SyndwsadataRequest(soap, "request", -1, &a->request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__Syndwsadata * SOAP_FMAC4 soap_in_ns__Syndwsadata(struct soap *soap, const char *tag, struct ns__Syndwsadata *a, const char *type)
{
	size_t soap_flag_request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__Syndwsadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__Syndwsadata, sizeof(struct ns__Syndwsadata), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_ns__Syndwsadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_SyndwsadataRequest(soap, "request", &a->request, "SyndwsadataRequest"))
				{	soap_flag_request--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_request > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns__Syndwsadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__Syndwsadata, SOAP_TYPE_ns__Syndwsadata, sizeof(struct ns__Syndwsadata), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__Syndwsadata * SOAP_FMAC2 soap_instantiate_ns__Syndwsadata(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__Syndwsadata(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__Syndwsadata *p;
	size_t k = sizeof(struct ns__Syndwsadata);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__Syndwsadata);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__Syndwsadata, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__Syndwsadata location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__Syndwsadata, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__Syndwsadata(struct soap *soap, const struct ns__Syndwsadata *a, const char *tag, const char *type)
{
	if (soap_out_ns__Syndwsadata(soap, tag?tag:"ns:Syndwsadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__Syndwsadata * SOAP_FMAC4 soap_get_ns__Syndwsadata(struct soap *soap, struct ns__Syndwsadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__Syndwsadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__SyndwsadataResponse(struct soap *soap, struct ns__SyndwsadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->serviceResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__SyndwsadataResponse(struct soap *soap, const struct ns__SyndwsadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSyndwsadataResponse(soap, &a->serviceResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__SyndwsadataResponse(struct soap *soap, const char *tag, int id, const struct ns__SyndwsadataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__SyndwsadataResponse), type))
		return soap->error;
	if (soap_out_PointerToSyndwsadataResponse(soap, "serviceResponse", -1, &a->serviceResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns__SyndwsadataResponse * SOAP_FMAC4 soap_in_ns__SyndwsadataResponse(struct soap *soap, const char *tag, struct ns__SyndwsadataResponse *a, const char *type)
{
	size_t soap_flag_serviceResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__SyndwsadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__SyndwsadataResponse, sizeof(struct ns__SyndwsadataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__SyndwsadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_serviceResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSyndwsadataResponse(soap, "serviceResponse", &a->serviceResponse, "SyndwsadataResponse"))
				{	soap_flag_serviceResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__SyndwsadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__SyndwsadataResponse, SOAP_TYPE_ns__SyndwsadataResponse, sizeof(struct ns__SyndwsadataResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns__SyndwsadataResponse * SOAP_FMAC2 soap_instantiate_ns__SyndwsadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns__SyndwsadataResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns__SyndwsadataResponse *p;
	size_t k = sizeof(struct ns__SyndwsadataResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns__SyndwsadataResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns__SyndwsadataResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns__SyndwsadataResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns__SyndwsadataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__SyndwsadataResponse(struct soap *soap, const struct ns__SyndwsadataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns__SyndwsadataResponse(soap, tag?tag:"ns:SyndwsadataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns__SyndwsadataResponse * SOAP_FMAC4 soap_get_ns__SyndwsadataResponse(struct soap *soap, struct ns__SyndwsadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__SyndwsadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SyndwsadataRequest(struct soap *soap, struct SyndwsadataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->requestVersion);
	soap_default_std__string(soap, &a->requestCtxUUID);
	soap_default_std__string(soap, &a->requestUserCode);
	soap_default_std__string(soap, &a->requestUserPwd);
	soap_default_std__string(soap, &a->requestUserName);
	soap_default_std__string(soap, &a->requestAppCls);
	soap_default_std__string(soap, &a->requestAppInst);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SyndwsadataRequest(struct soap *soap, const struct SyndwsadataRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->requestVersion);
	soap_serialize_std__string(soap, &a->requestCtxUUID);
	soap_serialize_std__string(soap, &a->requestUserCode);
	soap_serialize_std__string(soap, &a->requestUserPwd);
	soap_serialize_std__string(soap, &a->requestUserName);
	soap_serialize_std__string(soap, &a->requestAppCls);
	soap_serialize_std__string(soap, &a->requestAppInst);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SyndwsadataRequest(struct soap *soap, const char *tag, int id, const struct SyndwsadataRequest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SyndwsadataRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "requestVersion", -1, &a->requestVersion, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requestCtxUUID", -1, &a->requestCtxUUID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requestUserCode", -1, &a->requestUserCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requestUserPwd", -1, &a->requestUserPwd, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requestUserName", -1, &a->requestUserName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requestAppCls", -1, &a->requestAppCls, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requestAppInst", -1, &a->requestAppInst, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SyndwsadataRequest * SOAP_FMAC4 soap_in_SyndwsadataRequest(struct soap *soap, const char *tag, struct SyndwsadataRequest *a, const char *type)
{
	size_t soap_flag_requestVersion = 1;
	size_t soap_flag_requestCtxUUID = 1;
	size_t soap_flag_requestUserCode = 1;
	size_t soap_flag_requestUserPwd = 1;
	size_t soap_flag_requestUserName = 1;
	size_t soap_flag_requestAppCls = 1;
	size_t soap_flag_requestAppInst = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SyndwsadataRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SyndwsadataRequest, sizeof(struct SyndwsadataRequest), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_SyndwsadataRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_requestVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestVersion", &a->requestVersion, "xsd:string"))
				{	soap_flag_requestVersion--;
					continue;
				}
			if (soap_flag_requestCtxUUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestCtxUUID", &a->requestCtxUUID, "xsd:string"))
				{	soap_flag_requestCtxUUID--;
					continue;
				}
			if (soap_flag_requestUserCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestUserCode", &a->requestUserCode, "xsd:string"))
				{	soap_flag_requestUserCode--;
					continue;
				}
			if (soap_flag_requestUserPwd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestUserPwd", &a->requestUserPwd, "xsd:string"))
				{	soap_flag_requestUserPwd--;
					continue;
				}
			if (soap_flag_requestUserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestUserName", &a->requestUserName, "xsd:string"))
				{	soap_flag_requestUserName--;
					continue;
				}
			if (soap_flag_requestAppCls && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestAppCls", &a->requestAppCls, "xsd:string"))
				{	soap_flag_requestAppCls--;
					continue;
				}
			if (soap_flag_requestAppInst && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestAppInst", &a->requestAppInst, "xsd:string"))
				{	soap_flag_requestAppInst--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_requestVersion > 0 || soap_flag_requestCtxUUID > 0 || soap_flag_requestUserCode > 0 || soap_flag_requestUserPwd > 0 || soap_flag_requestUserName > 0 || soap_flag_requestAppCls > 0 || soap_flag_requestAppInst > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct SyndwsadataRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SyndwsadataRequest, SOAP_TYPE_SyndwsadataRequest, sizeof(struct SyndwsadataRequest), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SyndwsadataRequest * SOAP_FMAC2 soap_instantiate_SyndwsadataRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SyndwsadataRequest(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SyndwsadataRequest *p;
	size_t k = sizeof(struct SyndwsadataRequest);
	if (n < 0)
	{	p = SOAP_NEW(struct SyndwsadataRequest);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SyndwsadataRequest, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SyndwsadataRequest location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SyndwsadataRequest, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SyndwsadataRequest(struct soap *soap, const struct SyndwsadataRequest *a, const char *tag, const char *type)
{
	if (soap_out_SyndwsadataRequest(soap, tag?tag:"SyndwsadataRequest", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SyndwsadataRequest * SOAP_FMAC4 soap_get_SyndwsadataRequest(struct soap *soap, struct SyndwsadataRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_SyndwsadataRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SyndwsadataResponse(struct soap *soap, struct SyndwsadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->responseVersion);
	soap_default_std__string(soap, &a->requestCtxUUID);
	soap_default_std__string(soap, &a->responseCode);
	soap_default_std__string(soap, &a->responseExtCode);
	soap_default_std__string(soap, &a->responseMessage);
	soap_default_std__vectorTemplateOfPropInfoPojo(soap, &a->lstPropInfo);
	soap_default_std__vectorTemplateOfTermInfoPojo(soap, &a->lstTermInfo);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SyndwsadataResponse(struct soap *soap, const struct SyndwsadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->responseVersion);
	soap_serialize_std__string(soap, &a->requestCtxUUID);
	soap_serialize_std__string(soap, &a->responseCode);
	soap_serialize_std__string(soap, &a->responseExtCode);
	soap_serialize_std__string(soap, &a->responseMessage);
	soap_serialize_std__vectorTemplateOfPropInfoPojo(soap, &a->lstPropInfo);
	soap_serialize_std__vectorTemplateOfTermInfoPojo(soap, &a->lstTermInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SyndwsadataResponse(struct soap *soap, const char *tag, int id, const struct SyndwsadataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SyndwsadataResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "responseVersion", -1, &a->responseVersion, ""))
		return soap->error;
	if (soap_out_std__string(soap, "requestCtxUUID", -1, &a->requestCtxUUID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "responseCode", -1, &a->responseCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "responseExtCode", -1, &a->responseExtCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "responseMessage", -1, &a->responseMessage, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPropInfoPojo(soap, "lstPropInfo", -1, &a->lstPropInfo, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfTermInfoPojo(soap, "lstTermInfo", -1, &a->lstTermInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SyndwsadataResponse * SOAP_FMAC4 soap_in_SyndwsadataResponse(struct soap *soap, const char *tag, struct SyndwsadataResponse *a, const char *type)
{
	size_t soap_flag_responseVersion = 1;
	size_t soap_flag_requestCtxUUID = 1;
	size_t soap_flag_responseCode = 1;
	size_t soap_flag_responseExtCode = 1;
	size_t soap_flag_responseMessage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SyndwsadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SyndwsadataResponse, sizeof(struct SyndwsadataResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_SyndwsadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_responseVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "responseVersion", &a->responseVersion, "xsd:string"))
				{	soap_flag_responseVersion--;
					continue;
				}
			if (soap_flag_requestCtxUUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "requestCtxUUID", &a->requestCtxUUID, "xsd:string"))
				{	soap_flag_requestCtxUUID--;
					continue;
				}
			if (soap_flag_responseCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "responseCode", &a->responseCode, "xsd:string"))
				{	soap_flag_responseCode--;
					continue;
				}
			if (soap_flag_responseExtCode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "responseExtCode", &a->responseExtCode, "xsd:string"))
				{	soap_flag_responseExtCode--;
					continue;
				}
			if (soap_flag_responseMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "responseMessage", &a->responseMessage, "xsd:string"))
				{	soap_flag_responseMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPropInfoPojo(soap, "lstPropInfo", &a->lstPropInfo, "PropInfoPojo"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfTermInfoPojo(soap, "lstTermInfo", &a->lstTermInfo, "TermInfoPojo"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_responseVersion > 0 || soap_flag_requestCtxUUID > 0 || soap_flag_responseCode > 0 || soap_flag_responseExtCode > 0 || soap_flag_responseMessage > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct SyndwsadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SyndwsadataResponse, SOAP_TYPE_SyndwsadataResponse, sizeof(struct SyndwsadataResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SyndwsadataResponse * SOAP_FMAC2 soap_instantiate_SyndwsadataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SyndwsadataResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SyndwsadataResponse *p;
	size_t k = sizeof(struct SyndwsadataResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct SyndwsadataResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SyndwsadataResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SyndwsadataResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SyndwsadataResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SyndwsadataResponse(struct soap *soap, const struct SyndwsadataResponse *a, const char *tag, const char *type)
{
	if (soap_out_SyndwsadataResponse(soap, tag?tag:"SyndwsadataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SyndwsadataResponse * SOAP_FMAC4 soap_get_SyndwsadataResponse(struct soap *soap, struct SyndwsadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_SyndwsadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_TermInfoPojo(struct soap *soap, struct TermInfoPojo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->termId);
	soap_default_std__string(soap, &a->termName);
	soap_default_std__string(soap, &a->termIp);
	soap_default_std__string(soap, &a->propId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_TermInfoPojo(struct soap *soap, const struct TermInfoPojo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->termId);
	soap_serialize_std__string(soap, &a->termName);
	soap_serialize_std__string(soap, &a->termIp);
	soap_serialize_std__string(soap, &a->propId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TermInfoPojo(struct soap *soap, const char *tag, int id, const struct TermInfoPojo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_TermInfoPojo), type))
		return soap->error;
	if (soap_out_std__string(soap, "termId", -1, &a->termId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "termName", -1, &a->termName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "termIp", -1, &a->termIp, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propId", -1, &a->propId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct TermInfoPojo * SOAP_FMAC4 soap_in_TermInfoPojo(struct soap *soap, const char *tag, struct TermInfoPojo *a, const char *type)
{
	size_t soap_flag_termId = 1;
	size_t soap_flag_termName = 1;
	size_t soap_flag_termIp = 1;
	size_t soap_flag_propId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct TermInfoPojo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TermInfoPojo, sizeof(struct TermInfoPojo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_TermInfoPojo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_termId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "termId", &a->termId, "xsd:string"))
				{	soap_flag_termId--;
					continue;
				}
			if (soap_flag_termName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "termName", &a->termName, "xsd:string"))
				{	soap_flag_termName--;
					continue;
				}
			if (soap_flag_termIp && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "termIp", &a->termIp, "xsd:string"))
				{	soap_flag_termIp--;
					continue;
				}
			if (soap_flag_propId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "propId", &a->propId, "xsd:string"))
				{	soap_flag_propId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_termId > 0 || soap_flag_termName > 0 || soap_flag_termIp > 0 || soap_flag_propId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct TermInfoPojo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TermInfoPojo, SOAP_TYPE_TermInfoPojo, sizeof(struct TermInfoPojo), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct TermInfoPojo * SOAP_FMAC2 soap_instantiate_TermInfoPojo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_TermInfoPojo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct TermInfoPojo *p;
	size_t k = sizeof(struct TermInfoPojo);
	if (n < 0)
	{	p = SOAP_NEW(struct TermInfoPojo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct TermInfoPojo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct TermInfoPojo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_TermInfoPojo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_TermInfoPojo(struct soap *soap, const struct TermInfoPojo *a, const char *tag, const char *type)
{
	if (soap_out_TermInfoPojo(soap, tag?tag:"TermInfoPojo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct TermInfoPojo * SOAP_FMAC4 soap_get_TermInfoPojo(struct soap *soap, struct TermInfoPojo *p, const char *tag, const char *type)
{
	if ((p = soap_in_TermInfoPojo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PropInfoPojo(struct soap *soap, struct PropInfoPojo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->propId);
	soap_default_std__string(soap, &a->propName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PropInfoPojo(struct soap *soap, const struct PropInfoPojo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->propId);
	soap_serialize_std__string(soap, &a->propName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PropInfoPojo(struct soap *soap, const char *tag, int id, const struct PropInfoPojo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_PropInfoPojo), type))
		return soap->error;
	if (soap_out_std__string(soap, "propId", -1, &a->propId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "propName", -1, &a->propName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct PropInfoPojo * SOAP_FMAC4 soap_in_PropInfoPojo(struct soap *soap, const char *tag, struct PropInfoPojo *a, const char *type)
{
	size_t soap_flag_propId = 1;
	size_t soap_flag_propName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct PropInfoPojo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PropInfoPojo, sizeof(struct PropInfoPojo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	soap_default_PropInfoPojo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_propId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "propId", &a->propId, "xsd:string"))
				{	soap_flag_propId--;
					continue;
				}
			if (soap_flag_propName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "propName", &a->propName, "xsd:string"))
				{	soap_flag_propName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_propId > 0 || soap_flag_propName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct PropInfoPojo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_PropInfoPojo, SOAP_TYPE_PropInfoPojo, sizeof(struct PropInfoPojo), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct PropInfoPojo * SOAP_FMAC2 soap_instantiate_PropInfoPojo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_PropInfoPojo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct PropInfoPojo *p;
	size_t k = sizeof(struct PropInfoPojo);
	if (n < 0)
	{	p = SOAP_NEW(struct PropInfoPojo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct PropInfoPojo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct PropInfoPojo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_PropInfoPojo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PropInfoPojo(struct soap *soap, const struct PropInfoPojo *a, const char *tag, const char *type)
{
	if (soap_out_PropInfoPojo(soap, tag?tag:"PropInfoPojo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct PropInfoPojo * SOAP_FMAC4 soap_get_PropInfoPojo(struct soap *soap, struct PropInfoPojo *p, const char *tag, const char *type)
{
	if ((p = soap_in_PropInfoPojo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSyndwsaTicketInfoResponse(struct soap *soap, struct SyndwsaTicketInfoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SyndwsaTicketInfoResponse))
		soap_serialize_SyndwsaTicketInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSyndwsaTicketInfoResponse(struct soap *soap, const char *tag, int id, struct SyndwsaTicketInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SyndwsaTicketInfoResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SyndwsaTicketInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SyndwsaTicketInfoResponse ** SOAP_FMAC4 soap_in_PointerToSyndwsaTicketInfoResponse(struct soap *soap, const char *tag, struct SyndwsaTicketInfoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SyndwsaTicketInfoResponse **)soap_malloc(soap, sizeof(struct SyndwsaTicketInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SyndwsaTicketInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SyndwsaTicketInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SyndwsaTicketInfoResponse, sizeof(struct SyndwsaTicketInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSyndwsaTicketInfoResponse(struct soap *soap, struct SyndwsaTicketInfoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSyndwsaTicketInfoResponse(soap, tag?tag:"SyndwsaTicketInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SyndwsaTicketInfoResponse ** SOAP_FMAC4 soap_get_PointerToSyndwsaTicketInfoResponse(struct soap *soap, struct SyndwsaTicketInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSyndwsaTicketInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSyndwsadataResponse(struct soap *soap, struct SyndwsadataResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SyndwsadataResponse))
		soap_serialize_SyndwsadataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSyndwsadataResponse(struct soap *soap, const char *tag, int id, struct SyndwsadataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SyndwsadataResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SyndwsadataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SyndwsadataResponse ** SOAP_FMAC4 soap_in_PointerToSyndwsadataResponse(struct soap *soap, const char *tag, struct SyndwsadataResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SyndwsadataResponse **)soap_malloc(soap, sizeof(struct SyndwsadataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SyndwsadataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SyndwsadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SyndwsadataResponse, sizeof(struct SyndwsadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSyndwsadataResponse(struct soap *soap, struct SyndwsadataResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSyndwsadataResponse(soap, tag?tag:"SyndwsadataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SyndwsadataResponse ** SOAP_FMAC4 soap_get_PointerToSyndwsadataResponse(struct soap *soap, struct SyndwsadataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSyndwsadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag?tag:"QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag?tag:"string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfTermInfoPojo(struct soap *soap, std::vector<struct TermInfoPojo> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfTermInfoPojo(struct soap *soap, const std::vector<struct TermInfoPojo> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<struct TermInfoPojo> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_TermInfoPojo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfTermInfoPojo(struct soap *soap, const char *tag, int id, const std::vector<struct TermInfoPojo> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<struct TermInfoPojo> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_TermInfoPojo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct TermInfoPojo> * SOAP_FMAC4 soap_in_std__vectorTemplateOfTermInfoPojo(struct soap *soap, const char *tag, std::vector<struct TermInfoPojo> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfTermInfoPojo(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		struct TermInfoPojo n;
		soap_default_TermInfoPojo(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_TermInfoPojo, SOAP_TYPE_std__vectorTemplateOfTermInfoPojo, sizeof(struct TermInfoPojo), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_TermInfoPojo(soap, tag, NULL, "TermInfoPojo"))
				break;
		}
		else
		{	if (!soap_in_TermInfoPojo(soap, tag, &n, "TermInfoPojo"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(struct TermInfoPojo));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(struct TermInfoPojo));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(struct TermInfoPojo));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct TermInfoPojo>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfTermInfoPojo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfTermInfoPojo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<struct TermInfoPojo> *p;
	size_t k = sizeof(std::vector<struct TermInfoPojo> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<struct TermInfoPojo> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<struct TermInfoPojo> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<struct TermInfoPojo>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfTermInfoPojo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPropInfoPojo(struct soap *soap, std::vector<struct PropInfoPojo> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPropInfoPojo(struct soap *soap, const std::vector<struct PropInfoPojo> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<struct PropInfoPojo> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PropInfoPojo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPropInfoPojo(struct soap *soap, const char *tag, int id, const std::vector<struct PropInfoPojo> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<struct PropInfoPojo> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PropInfoPojo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct PropInfoPojo> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPropInfoPojo(struct soap *soap, const char *tag, std::vector<struct PropInfoPojo> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPropInfoPojo(soap)))
			return NULL;
		else if (a->size() >= soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		struct PropInfoPojo n;
		soap_default_PropInfoPojo(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_PropInfoPojo, SOAP_TYPE_std__vectorTemplateOfPropInfoPojo, sizeof(struct PropInfoPojo), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PropInfoPojo(soap, tag, NULL, "PropInfoPojo"))
				break;
		}
		else
		{	if (!soap_in_PropInfoPojo(soap, tag, &n, "PropInfoPojo"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(struct PropInfoPojo));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(struct PropInfoPojo));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(struct PropInfoPojo));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct PropInfoPojo>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPropInfoPojo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPropInfoPojo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<struct PropInfoPojo> *p;
	size_t k = sizeof(std::vector<struct PropInfoPojo> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<struct PropInfoPojo> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<struct PropInfoPojo> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<struct PropInfoPojo>  location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPropInfoPojo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
